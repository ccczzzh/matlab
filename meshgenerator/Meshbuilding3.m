%**************************************************************************
% This program is used to produce multi_scale finite element mesh. 
% The inputs are the number of rows and columns of the mesh, number of rows
% and cloumns of macro elements, number of rows and columns of elements
% within a RVE, boundary width and height.
% One thing need to pay attention is the layout of the macro element, which
% might need to change after building one mesh after another, the length
% and the width of an micro element need to be changed when building a new
% mesh
%
% In this program, assuming all the macro elements/RVEs are identical
%
% The biggest limitation to this program is this program could only build a
% mesh with 4 noded rectangle elements, which means not only the macro 
% elements but also the micro elements wich in the RVEs are rectangle and 
% the whole model must be a uniformed plane with no holes or cracks.
 
% Assume all the macro element contains 9 RVEs, which are arraying 3 by 3
 
% Model with void is also need to be built. In this modification, model
% with void could be built. The main problem of making a void is with the
% void, the model is no longer fully continuu, so need special care. 
 
% The limitation to this mesh building is the void must be a Macro element
% size, and at one of the Macro element position. The main idea of making a
% void is finding the nodes that in the void, and delete them, and the
% following numbers will shift forward and fill in the blank point caused
% by the cutting off. As for the elnods, this part is quite tricky, the
% first trials are aimed on doing the 'shift', however mistakes are easily
% come out, so another way been used. 
 
% The reason that making this 'mesh generator' is because the elements in
% the model is in a large number, hard to build directly, the second reason
% is the special data structure is required while applying the code, since 
% the elnod need to be appeared in the sequence ['number' 'elment group'
% 'nodes composition'], which is different than the data structure that 
% generated by most of softwares, and it's hard to 'mpodify' those data 
% (add the element group inside).
 
% Before hand, tried to simulate the void as elemnts with infinitesmal
% Young's Modulus, but the result seems not that ideal, maybe the way to do
% the calcualtion need to be changed. While calcualte the D matrix for each
% element group, the way that taking the material properity is use the
% current elemnt group devide the total number of material types, and the
% remainder will indicate the current element groups' material type,
% however, this method require the material types having a unique sequence,
% or say the coposition of each RVE is the same, whereas void or RVEs from
% different Macro element consists diffenent material is totally different
% than the calculation used to, so might be need to change the way of
% taking the material properity for element groups from the main code.
 
%**************************************************************************
 
% Characters that need to change to build a new mesh: number of rows and
% columns of RVEs in each modol; allocation of the element groups; and the 
% composition of RVEs, the position of the macro elements
 
%******************
% Calculating Phase
%******************
clear
 
tic
 
mer = 4; % number of rows of macro elements
mec = 4; % number of columns of macro elements
ele_r = 6; % number of rows of elements within a RVE
ele_c = 6; % number of columns of elements within a RVE
w = 12; % width of the whole model
h = 12; % height of the whole model
 
r = ele_r*3*mer+1; % number of rows in the discretised mesh
c = ele_c*3*mec+1; % number of columns in the discretised mesh
 
% phase_number consists two numbers, the frist number indicate the total 
% number of phases the model has, a phase means one type of RVE, if it 
% equals to 1, that means RVEs are the same from one Macro element to 
% another, if it equals to 2, that means the whole model have 2 different
% RVEs, ie the model has two different type of Macro elements. The secone
% number indicates if the model has void, 1 means the model HAS void(s), 0 
% means the model don't have voids.
phase_number = 10; 
 
phase_check = round(phase_number/10);
void_check = phase_number - phase_check*10;
 
if void_check == 1
    macro_element_width  = w/mec;
    macro_element_height = h/mer;
    voids = 4; % if voids = 0, no void at all, if void ~= 0, then voids equals to the number of voids
    if voids ~= 0
        % each row indicates the void's center's coordinate
        voids_position = [ 10.5, 10.5  ;
                           10.5, 13.5  ;
                           13.5, 10.5  ;
                           13.5, 13.5 ]; 
        [j,~] = size(voids_position);
        if j ~= voids
            error('The number of voids is different than expected')
        end
        for ivoid = 1:voids
            check5 = (w-2*voids_position(ivoid,1))/macro_element_width ;
            check6 = (h-2*voids_position(ivoid,2))/macro_element_height;
            if check5 ~= round(check5) || check6 ~= round(check6)
                error('Please rearrange the position of the voids');
            end
        end
    end
else
    voids = [];
end
elnods = [];
count = 1;
for i = 0:r-2 % number of rows - 2
    for j = 1:c-1   % number of column - 1
        b = i*c+j; % number of column
        elnods = [ elnods; count b b+1 c+b+1 c+b ] ;
        count = count + 1;
    end
end
 
% The layout of the elements in a RVE, different number indicates different
% element group. For different test, the layout need to be changed over
% different tests.
if phase_check == 1
    elgpr1 = [  1 1 1 2 2 2  ;
                1 1 1 2 2 2  ;
                1 1 1 2 2 2  ;
                2 2 2 1 1 1  ;
                2 2 2 1 1 1  ;
                2 2 2 1 1 1 ];
    [check1,check2] = size(elgpr1);
    if check1 ~= ele_r || check2 ~= ele_c
        error('The layout of the element within an RVE is different than planned, please rearrange the layout.')
    end
    % Because the building of elnods need to make sure the element group with
    % in a RVE MUST be continue, so make the following check
    check3_1 = length(unique(elgpr1)); maxi_number_elgp = max(elgpr1(:));
    if check3_1 ~= maxi_number_elgp
        error('The layout of the element group within a RVE need to be changed')
    end
    elgprc = elgpr1;
    % build up the micro element layout for the macro elements at the bottom of
    % the whole model
    elgpr0 = elgpr1;
    for i = 1:mec*3-1
        elgpr0 = [ elgpr0, elgprc+i*maxi_number_elgp ];
    end
    % build up the micro element layout for each row of macro elements
    elgpr = {};
    for i = 1:mer*3-1 % number of layers of RVEs - 1
        elgpr{i} = elgpr0 + 3*maxi_number_elgp*mec*i; % number of element groups per-layer of RVE
    end
    % assumble all layout together
    elgp = elgpr0;
    for i = 1:mer*3-1
        elgp = [ elgp; elgpr{i} ];
    end
    elgp = elgp';
    el = elgp(:);
    phase_member{1} = 1:mer*mec; % used for model with several phase
    mtltyp = length(unique(elgpr1));
    final_layout = 1:mer*mec; % used for model with void
else
    % RVE from different phase have different dicomposion, hence need to
    % demonstrate the lay out of RVE form different phase. Need to make
    % sure RVEs from different Phase are still sharing the same size, and
    % this is the limitation to this code.
    elgpr{1} = [  1 1 1 1 1  ;
                  1 2 2 2 1  ;
                  1 2 2 2 1  ;
                  1 2 2 2 1  ;
                  1 1 1 1 1  ];
    elgpr{2} = [  1 1 1 1 1  ;
                  1 2 2 2 1  ;
                  1 2 2 2 1  ;
                  1 2 2 2 1  ;
                  1 1 1 1 1 ];
    check_type = length(elgpr);
    if check_type ~= phase_check
        error('The phase number is different than supposed')
    end
    for iphase = 1:phase_check-1
        [i,j] = size(elgpr{iphase});
        [k,l] = size(elgpr{iphase+1});
        if i ~= k || j ~= l
            error('The size of RVEs form different phase must be same')
        end
    end
    % if there's 0 in the phase_layout, that means there's a void
    phase_layout = [ 1 2 1 2 1 2 1 2 ;
                     2 1 2 1 2 1 2 1 ;
                     1 2 1 2 1 2 1 2 ;
                     2 1 2 1 2 1 2 1 ;
                     1 2 1 2 1 2 1 2 ;
                     2 1 2 1 2 1 2 1 ;
                     1 2 1 2 1 2 1 2 ;
                     2 1 2 1 2 1 2 1 ];
    [m,n] = size(phase_layout);
    if m ~= mer || n ~= mec
        error('The Macro element layout is different than expected')
    end
    lineup = phase_layout';
    lineup = lineup(:);
    dummy_layout = 1:mer*mec;
    dummy_layout = dummy_layout';
    final_layout = zeros(mer*mec,1);
    phase_member = {};
    v = 0;
    for iphase = 1:phase_check
        pick = find(lineup == iphase);
        final_layout(pick) = v+1:v+length(pick);
        phase_member{iphase} = 1+v:length(pick)+v;
        v = length(pick);
    end
    final_layout = reshape(final_layout,n,m);
    final_layout = final_layout';
    mtltyp = [];
    for iphase = 1:phase_check
        mtltyp(iphase) = length(unique(elgpr{iphase}));
    end
    dummy_el = zeros(ele_r*3,ele_c*3);
    final_el = zeros(ele_r*3*mer,ele_c*3*mec);
    for iphase = 1:phase_check
        count = 1;
        for i = 1:3
            for j = 1:3
                dummy_el(1+(i-1)*ele_r:ele_r*i,1+(j-1)*ele_c:ele_c*j) = elgpr{iphase} + (count-1)*mtltyp(iphase);
                count = count + 1;
            end
        end
        phase_base{iphase} = dummy_el;
    end
    for i = 1:m
        for j = 1:n
            phase = phase_layout(i,j);
            minute = final_layout(i,j);
            if minute ~= 0
                multiplyer = find(minute == phase_member{phase});
                if phase == 1
                    final_el(1+(i-1)*ele_r*3:ele_r*3*i,1+(j-1)*ele_c*3:ele_c*3*j) = phase_base{phase} + (multiplyer-1)*mtltyp(phase)*9;
                end
                if phase > 1
                    extra = 0;
                    for hhh = 1:phase-1
                        extra = extra + length(phase_member{hhh})*9*mtltyp(hhh);
                    end
                    final_el(1+(i-1)*ele_r*3:ele_r*3*i,1+(j-1)*ele_c*3:ele_c*3*j) = phase_base{phase} + (multiplyer-1)*mtltyp(phase)*9 + extra;
                end
            end
        end
    end
    final_el = final_el';
    el = final_el(:);
     
    maxi_number_elgp = 0;
    for iphase = 1:phase_check
        maxi_number_elgp = maxi_number_elgp + mtltyp(iphase);
    end
    final_layout = final_layout';
    final_layout = final_layout(:);
end
 
% assumble the whole elnods
[o,p] = size(elnods);
elnod = zeros(o,p+1);
elnod(:,1) = elnods(:,1);
% elnod(:,2) = elnods(:,2);
elnod(:,2) = el;
elnod(:,3:p+1) = elnods(:,2:p);
 
% build up the coordinates for the whole model
node_coordinate = [];
count = 1;
for i = 0:h/(r-1):h
    for j = 0:w/(c-1):w
        node_coordinate = [ node_coordinate; count j i ];
        count = count + 1;
    end
end
 
% for this part, build the vector indicates which element group is in which
% RVE, this depends on how many elements a RVE contains, due to all the RVE
% are identical, therefore this part could be built
gpsnRVE = [];
count = 1;
total_RVE = 0;
for iphase = 1:phase_check
    total_RVE = total_RVE + 9*length(phase_member{iphase});
end
gpsnRVE = zeros(total_RVE,max(mtltyp)+1);
count = 1;
for iphase = 1:phase_check
    gpnphs(iphase) = 9*length(phase_member{iphase});
end
maxi_gp = 0;
for iphase = 1:phase_check
    for i = 0:gpnphs(iphase)-1 % the number of RVEs - 1
        blank = max(mtltyp) - mtltyp(iphase);
        gpsnRVE(count,:) = [ count 1+mtltyp(iphase)*i+maxi_gp 2+mtltyp(iphase)*i+maxi_gp zeros(blank,1)];
        count = count + 1;
    end
    maxi_gp = max(max(gpsnRVE));
end
 
if phase_check == 1
    RVE_basic = [1 2 3];
    RVE_row = [];
    for i = 1:3 % assuming each macro element contains 9 RVEs (3 by 3)
        RVE_row = [RVE_row RVE_basic+(i-1)*3*mec]; % number of RVEs in a layer of RVE
    end
    RVEC = [];
    for i = 1:mec % number of columns of macro element
        RVEC = [RVEC; RVE_row + (i-1)*3]; % assuming each macro element contains 9 RVEs (3 by 3)
    end
    RVEM = [];
    for i = 1:mer % number of rows of macro elements
        RVEM = [RVEM; RVEC + (i-1)*9*mec]; %number of RVEs per layer of macro elements
    end
    count = 1:mer*mec;
    RVEM = [count' RVEM];
else
    count = 1;
    RVEM = [];
    void_macro = length(find(lineup == 0));
    for i = 1:mer*mec-void_macro % take out the void macro elements
        base = 1:9;
        RVEM = [ RVEM; count base+(i-1)*9 ];
        count = count + 1;
    end
end
 
% List out the fixed nodes number and their displacements
fix_node_left = 1;
fix_node_right = c;
priscribed = [];
for i = 1:r
    priscribed = [             priscribed            ; 
                   fix_node_left+(i-1)*c  10  0   0  ;
                   fix_node_right+(i-1)*c 10 w/10 0 ];
end
 
%*****************
% Try to make void
%*****************
if void_check == 1
    % build the void first and find nodes in it
    void_nodes = [];
    for ivoid = 1:voids
        void_left  = voids_position(ivoid,1) - macro_element_width/2 ;
        void_right = voids_position(ivoid,1) + macro_element_width/2 ;
        void_botom = voids_position(ivoid,2) - macro_element_height/2;
        void_top   = voids_position(ivoid,2) + macro_element_height/2;
        void_nodes_x = find(node_coordinate(:,2)>void_left & node_coordinate(:,2)<void_right);
        void_nodes_y = find(node_coordinate(:,3)>void_botom & node_coordinate(:,3)<void_top );
        dummy_nodes = intersect(void_nodes_x,void_nodes_y);
        void_nodes = [void_nodes; dummy_nodes];
    end
    node_coordinate(void_nodes,:) = []; % pick out the 'void nodes' from the coordinates
    % rebuild the sequence for the coordinates
    dummy_count = unique(node_coordinate(:,1));
    count = length(dummy_count);
    node_coordinate(:,1) = 1:count;
 
    elnod(elnod(:,2)==0,:) = [];
    % after taking out those void nodes from the original mesh, several
    % nodes are allocated with new node number, meanwhile, after picking 
    % out the 'void elements' from the elnod, the composition of elnod is
    % no longer compact, therefore need to replace the 'wrong' member in
    % elnods to the actural(new) node number.
    [m,~] = size(elnod);
    for i = 1:m
        for j = 3:6
            k = find(elnod(i,j) == dummy_count);
            elnod(i,j) = k;
        end
    end
    sequence = elnod(:,1);
    elnod(:,1) = 1:length(unique(sequence));
     
    % since nodes numbers are shifted after picking out the void, no doubt
    % the pricribed nodes number are varied, hence use the easiest way to
    % find out those priscribed nodes' node number.
    priscribed_x = find(node_coordinate(:,2) == 0);
    priscribed(1:2:2*c,1) = priscribed_x;
    priscribed_y = find(node_coordinate(:,2) == w);
    priscribed(2:2:2*c,1) = priscribed_y;
end
 
%******************
% Writting-in Phase
%******************
fid = fopen('new_mesh.dat','w');
 
[R1,C1]=size(elnod);
formatSpec = 'ELEMENTS = %8.0f\n';
fprintf(fid,formatSpec,R1);
for i=1:R1
    for j=1:C1
        fprintf(fid,'%7.0f',elnod(i,j));
    end
    fprintf(fid,'\n');
end
fprintf(fid,'\n');
 
[R2,C2]=size(node_coordinate);
formatSpec = 'NODE_COORDINATES = %6.0f\n';
fprintf(fid,formatSpec,R2);
for i=1:R2
    fprintf(fid,'%5.0d %12.6f %12.6f',node_coordinate(i,:));
    fprintf(fid,'\n');
end
fprintf(fid,'\n');
 
fprintf(fid, 'THICKNESS = 1\n\n');
fprintf(fid, 'OPTION = Dirichlet\n\n');
fprintf(fid, 'DIRICHLET BOUNDARY = 24\n\n');
[R3,C3]=size(gpsnRVE);
formatSpec = 'NUMBER_OF_RVE =  %8.0f\n\n';
fprintf(fid,formatSpec,R3);
formatSpec = 'LARGEST_RVE = %8.0f\n';
fprintf(fid,formatSpec,C3-1);
for i=1:R3
    for j=1:C3
        fprintf(fid,'%5.0f',gpsnRVE(i,j));
    end
    fprintf(fid,'\n');
end
fprintf(fid,'\n');
 
formatSpec = 'NUMBER_OF_MACRO_ELEMENTS = %6.0f\n';
if isempty(voids)
    voids = 0;
end
fprintf(fid,formatSpec,mer*mec-voids);
formatSpec = 'NUMBER_OF_ROWS= %4.0f\n';
fprintf(fid,formatSpec,mer);
formatSpec = 'NUMBER_OF_COLUMNS = %4.0f\n';
fprintf(fid,formatSpec,mec);
fprintf(fid,'\n');
fprintf(fid, 'NUMBER_OF_RVE_CONTAINED = 9\n');
[R4,C4]=size(RVEM);
for i=1:R4
    for j=1:C4
        fprintf(fid,'%5.0f',RVEM(i,j));
    end
    fprintf(fid,'\n');
end
fprintf(fid,'\n');
 
formatSpec = 'NODES_WITH_PRESCRIBED_DISPLACEMENTS = %7.0f\n';
fprintf(fid,formatSpec,r*2);
[R5,~]=size(priscribed);
for i=1:R5
    fprintf(fid,'%5.0d %4.0f %6.3f %6.3f',priscribed(i,:));
    fprintf(fid,'\n');
end
fprintf(fid,'\n');
 
fprintf(fid, 'POINT_LOADS = 0\n\n');
fprintf(fid, 'PLOTTING_AMPLIFICATION_FACTOR = 10\n\n');
 
formatSpec = 'NUMBER_OF_MACRO_ELEMENTS = %5.0f\n';
 
fprintf(fid,formatSpec,length(final_layout));
for i = 1:length(final_layout)
    fprintf(fid,'%5.0f',final_layout(i));
end
fprintf(fid,'\n');
fprintf(fid,'\n');
 
fprintf(fid, 'PHASE_NUMBER = 21\n\n');
 
material_count(:,1) = 1:phase_check;
for iphase = 1:phase_check
    material_count(iphase,2) = mtltyp(iphase);
    material_count(iphase,3) = mtltyp(iphase)*9*length(phase_member{iphase});
    material_count(iphase,4) = max(phase_member{iphase});
end
for i = 1:phase_check
    fprintf(fid,'%5.0d %4.0f %6.0f %6.0f',material_count(i,:));
    fprintf(fid,'\n');
end
 
fclose(fid);
 
toc    
    